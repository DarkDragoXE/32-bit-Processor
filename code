`timescale 1ns / 1ps

////Fields of IR
`define opertype IR[31:27]  ////operation
`define rdst     IR[26:22]  ////destination
`define rsrc1    IR[21:17]  ////source 1
`define immemode IR[16]     //// immediate mode
`define rsrc2    IR[15:11]  ////source2
`define isrc     IR[15:0]   ////if mode sel is 1

//// arithemtic operation
`define movsgpr     5'b00000 ////special reg --> mul between content of two reg
`define mov         5'b00001 //// numeric data copy
`define add         5'b00010 //// addition of rdst->rsrc1+rsrc2(imm)
`define sub         5'b00011 //// subtraction
`define mul         5'b00100 //// multiplication 

////////////// logical operations 

`define ror          5'b00101 
`define rand         5'b00110 
`define rxor         5'b00111
`define rxnor        5'b01000
`define rnand        5'b01001
`define rnor         5'b01010 
`define rnot         5'b01011 

 module processor();




reg [31:0] IR; ////instruction register <--ir[31:27]--><--><--ir[26:22]--><--ir[21:17]--><--ir[16]--><--ir[15:11}--><--ir{10:0]-->
               ////instruction register <--   oper  --><--><--  dest   --><-- source1 --><-- mode --><-- source2 --><-- unused -->
               ////instruction register <--   oper  --><--><--  dest   --><-- source1 --><-- mode --><--    immediate date     -->
reg [15:0] GPR [31:0]; ////gen purpose reg gpr[0] .... gpr[31]
reg [15:0] SGPR ; //// msb of multiplication --> special register
reg [31: 0] mulres;

always @(*)
begin 
case(`opertype)
////////arithmetic 
`movsgpr: begin
    GPR[`rdst] = SGPR;
end
`mov : begin
    if(`immemode)
        GPR[`rdst] = `isrc;
    else
        GPR[`rdst] = GPR[`rsrc1];
end
///////////////
`add :
begin
    if(`immemode)
        GPR[`rdst]= GPR[`rsrc1] + `isrc;
    else
        GPR[`rdst]= GPR[`rsrc1] + GPR[`rsrc2];
end
/////////////
`mul : begin
    if (`immemode)
        mulres = GPR[`rsrc1]*`isrc;
    else
        mulres = GPR[`rsrc1]*GPR[`rsrc2];
        
    GPR[`rdst] = mulres[15:0];
    SGPR = mulres[31:16];
end
////////logic
////////bitwise or 
`ror : begin
    if (`immemode)
        GPR[`rdst] = GPR[`rsrc1]|`isrc;
    else
        GPR[`rdst] = GPR[`rsrc1]|GPR[`rsrc2];
end
/////bitwise and
`rand : begin
    if (`immemode)
        GPR[`rdst] = GPR[`rsrc1]&`isrc;
    else
        GPR[`rdst] = GPR[`rsrc1]& GPR[`rsrc2];
end
////////////bitwise xor
`rxor : begin
    if (`immemode)
        GPR[`rdst] = GPR[`rsrc1]^`isrc;
    else
        GPR[`rdst] = GPR[`rsrc1]^GPR[`rsrc2];
end
//////// bitwise xnor
`rxnor : begin
    if (`immemode)
        GPR[`rdst] = GPR[`rsrc1]~^`isrc;
    else
        GPR[`rdst] = GPR[`rsrc1]~^GPR[`rsrc2];
end
/////////bitwise nand
`rnand : begin
    if (`immemode)
        GPR[`rdst] = ~(GPR[`rsrc1]&`isrc);
    else
        GPR[`rdst] = ~(GPR[`rsrc1]&GPR[`rsrc2]);
end
/////////////bitwise nor
`rnor : begin
    if (`immemode)
        GPR[`rdst] = ~(GPR[`rsrc1]|`isrc);
    else
        GPR[`rdst] = ~(GPR[`rsrc1]|GPR[`rsrc2]);
end
//////////// not
`rnot :begin
    if (`immemode)
        GPR[`rdst] = ~ (`isrc);
    else
        GPR[`rdst]= ~(GPR[`rsrc1]);
end
endcase
end
/////////////////////////////////////////
//////////////////////// logic for condtion flag
reg sign = 0, zero= 0, overflow=0, carry = 0;
reg [16:0] tempsum;

always @(*)
begin
//sign bit
if (`opertype== `mul)
    sign = SGPR[15];
else
    sign = GPR[`rdst][15];
     
//////carry bit
if (`opertype == `add)
    begin   
    if(`immemode)
        begin
        tempsum = GPR[`rsrc1] + `isrc;
        carry = tempsum[16];
        end
    else 
    begin
    tempsum = GPR[`rsrc1] + GPR[`rsrc2];
    carry = tempsum[16];
end end
else 
begin 
carry = 1'b0;
end
////////////zero bit
if (`opertype == `mul)
zero= ~((|SGPR[15]) | (|GPR[`rdst]));
else 
zero = ~(|GPR [`rdst]); 
//// overflow bit 
if (`opertype == `add)
    begin
        if(`immemode)
            overflow = ((~GPR[`rsrc1][15] & ~ IR[15] & GPR[`rdst][15]) | (GPR[rsrc1][15] & IR[15] & ~GPR[`rdst][15]));

end 
endmodule






//////////////////////////test bench/////////////////////////////////////////////////////////////////////////

`timescale 1ns / 1ps

module proctb;
integer i=0;
processor dut();

initial begin
for (i=0; i<32; i=i+1)
begin
dut.GPR[i]=2;
end
end


initial begin 
/////immediate op
$display("----------------------------");
dut.IR=0;
dut.`immemode =1;
dut.`opertype=2;
dut.`rsrc1=2; ////gpr[2] =2
dut.`rdst=0;  ////gpr[0]
dut.`isrc=4;
#10;
$display("OP:ADI Rsrc1:%0d Rdst:%0d", dut.GPR[2], dut.`isrc, dut.GPR[0]);
$display("----------------------------");
////////// reg add op
 
$display("OP:ADD Rsrc1:%0d Rdst:%0d", dut.GPR[4], dut.GPR[5], dut.GPR[0]);
$display("----------------------------");
/////////// immediate mov op
dut.IR=0;
dut.`immemode =1;
dut.`opertype=1;
dut.`rdst=4;  ////gpr[4]
dut.`isrc=55;
$display("OP:MOVI Rdst:%0d immdata:%0d",dut.GPR[4], dut.`isrc);
$display("----------------------------");
///////////////////////// register mov
dut.IR=0;
dut.`immemode =0;
dut.`opertype=1;
dut.`rdst=4;  ////gpr[4]
dut.`rsrc1=7; ////gpr[7]
#10;
////copying content of reg 7 in reg 4
$display("OP:MOV Rdst:%0d Rsrc1:%0d",dut.GPR[4], dut.GPR[7]);
$display("----------------------------");

///////// logical and imm
dut.IR=0;
dut.`immemode =1;
dut.`opertype=6;
dut.`rsrc1=7; 
dut.`rdst=4;
dut.`isrc=56;
#10;
$display("OP:ANDI Rdst:%8b, Rsrc1:%8b immD:%8b", dut.GPR[4], dut.GPR[7], dut.`isrc);
$display("----------------------------");

///////// logical xor imm
dut.IR=0;
dut.`immemode =1;
dut.`opertype=7;
dut.`rsrc1=7; 
dut.`rdst=4;
dut.`isrc=56;
#10;
$display("OP:XORI Rdst:%8b, Rsrc1:%8b immD:%8b", dut.GPR[4], dut.GPR[7], dut.`isrc);
$display("----------------------------");



///////// logical or src2

dut.IR=0;

dut.`immemode =0;

dut.`opertype=5;

dut.`rsrc1=16;

dut.`rdst=0;

dut.`rsrc2=4;

#10;

$display("OP:OR Rdst:%8b, Rsrc1:%8b Rsrc2:%8b", dut.GPR[0], dut.GPR[16], dut.GPR[4]);

$display("----------------------------");



///////// logical nor src2

dut.IR=0;

dut.`immemode =0;

dut.`opertype=10;

dut.`rsrc1=16;

dut.`rdst=0;

dut.`rsrc2=4;

#10;

$display("OP:NOR Rdst:%8b, Rsrc1:%8b Rsrc2:%8b", dut.GPR[0], dut.GPR[16], dut.GPR[4]);

$display("----------------------------");

end
endmodule









